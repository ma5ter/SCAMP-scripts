; common TOS sizes\nb equ 0\nw equ 1\ndw equ 2\n\n;sections equ 1 ; (param) monitored sections mask\n;timer equ 5 ; (param) time of alarm\n;include_panic equ 1 ; (param) include panic alarm\n;include_delays equ 1 ; (param) include delays processing\n;include_arm_disarm_signals equ 1 ; (param) include signals of arm/disarm\nmask equ 128 ; mask of blink\n\npb macro ; byte\n psh (($1 >> 4) & 15)\n nib ($1 & 15)\nendm\n\n; push word macro\npw macro\n psh (($1 >> 12) & 15)\n nib (($1 >> 8) & 15)\n psh (($1 >> 4) & 15)\n nib ($1 & 15)\nendm\n\nup macro\n psh (((($1 & 3) | ($2 << 2)) >> 4) & 15)\n nib (($1 & 3) | ($2 << 2) & 15)\n mov\nendm\n\n; stack template\n; - last state - 1 byte\n; - signal counter - 1 byte\n; - armed flag - 1 byte\n; - was walarmed flag - 1 byte\n; - timer end time - 2 bytes\n; - -|-|-|-\n\n;BEGIN\ncheck_signal\n swp b ; bring 'signal counter' to top\n ; if 'signal counter' has value - check timer\n ; else - check arming guard sections\n snz\n bra no_signal\nhas_signal\n pb check_signal_timer\n jmp b\nno_signal\n pop b ; dispose 'signal counter'\n ; get switch\n pb HAS_SWITCH\n inp b, b\n pop b ; read switch\n ; if has switch - disable\n ; else - check arming\n skz\n bra check_last_state\n pop b ; dispose 'last state'\n bra check_arming\ncheck_last_state\n pop b ; read 'last state'\n ; if was off - no need to turning off, check arming\n snz\n bra check_arming ; 0\nmanually_disable\n up dw, 1 ; bring 'alarmed flag' and 'timer end time' to top\n pop dw ; dispose 'alarmed flag' and 'timer end time'\n psh 1 ; set 'alarmed flag'\n pb swap_and_off\n jmp b\n\ncheck_arming\n dup b ; save 'armed flag'\n ; get guard sections mask\n psh GUARD_SECTIONS\n inp b, b\n pb sections ; get monitored sections mask\n and b ; calculate which guard sections are monitored\n ; get armed sections mask\n psh ARMED_SECTIONS\n inp b, b\n pb sections ; get monitored sections mask\n and b ; calculate which armed sections are monitored\n ; compare 'monitored guard sections' and 'monitored armed sections'\n ; if equal - all device armed - check entry delay 0\n ; else - device disarmed - 1 - check exit delay\n cmp b\n psh 0 ; current arm state base\n ; if device armed - change current arm state to 1\n ; else - left 0 as is\n snz\n nib 1\n xor b ; calculate arm changing status\n pop b\n ; if device did not change arm status - check alarm\n ; else - check last arm status\n skz\n bra check_armed_flag ; 1\n swp b ; bring 'alarmed flag' to top\n\ncheck_alarmed_flag\n pop b ; read 'alarmed flag'\n ; if alarmed - check if alarms there still\n ; else - go check panic\n skz\n bra check_if_has_any_alarm\n pb check_for_panic\n jmp b\n\ncheck_if_has_any_alarm\n ; get panic state considering 'include panic' flag\n pb PANIC\n inp b, b\n psh include_panic\n and b\n ; get alarms considering monitored sections\n psh ALARMING_SECTIONS\n inp b, b\n pb sections\n and b\n ior b ; combine alarms and panic\n pop b\n psh 0 ; set base of 'alarmed' flag\n ; if there still some alarm - set 'alarmed' = 1\n ; else - left 'alarmed' = 0\n skz\n nib 1 ; set 'alarmed'\n pb swap_and_off\n jmp b\n \ncheck_armed_flag\n dup b ; save 'armed flag'\n pop b ; check 'armed flag'\n ; if was armed - check entry delay\n ; else - check exit delay\n snz\n bra check_exit_delay ; was disarmed\ncheck_entry_delay\n psh include_delays ; get include dalay parameter\n pop b\n ; if include - check entry delay\n snz\n bra dispose_armed_flag\n ; get entry delay\n psh ENTRY_DELAY\n inp b, b\n pop b\n ; if has 'entry delay' - process delay, but do not reset 'armed' flag yet\n ; else reset 'armed' flag and make signal\n skz\n bra delay ; 1\ndispose_armed_flag\n swp w ; bring 'timer end time' to top\n pop w ; dispose 'timer end time'\n pop b ; dispose 'armed' flag\n psh 0 ; set 0 to 'armed' flag\n psh 0 ; set 'signal counter' initial value\n psh include_arm_disarm_signals ; get include arm/disarm signals parameter\n pop b ; read include arm/disarm signals\n ; if include arm/disarm signal - set 'signal counter' = 8\n ; else leave 'signal counter' = 0\n skz\n nib 8 ; set 'signal counter'\n psh 0 ; set off relay state\n ret\n\ncheck_exit_delay\n psh include_delays ; get include dalay parameter\n pop b\n ; if include - check entry delay\n snz\n bra set_armed_and_make_signal\n ; get exit delay\n psh EXIT_DELAY\n inp b, b\n pop b\n ; if has exit delay - set off\n ; else - make signal\n skz\n bra delay ; 1\nset_armed_and_make_signal\n swp w ; bring 'timer end time' to top\n pop w ; dispose 'timer end time'\n pop b ; dispose 'armed flag'\n psh 1 ; set 'armed flag'\n psh 0 ; set 'signal counter' initial value\n psh include_arm_disarm_signals ; get include arm/disarm signals parameter\n pop b ; read include arm/disarm signals\n ; if include arm/disarm signal - set 'signal counter' = 8\n ; else leave 'signal counter' = 0\n skz\n nib 2 ; set 'signal counter' = 2\n psh 0 ; set relay off state\n ret\n\ndelay\n psh 0 ; set 'signal counter'\n psh 0 ; set off relay state\n ret\n\ncheck_signal_timer\n up w, 4 ; bring 'timer end time' to top\n dup w\n pop w\n snz\n bra timeout4\n dup w ; save 'timer end time'\n ; get current ticks\n psh TICKS\n inp b, w\n ; compare 'timer end time' and current ticks\n ; if current ticks is greater - time is out\n ; else - continue\n cmp w\n skp\n bra timeout4\ncontinue_signal_or_gap\n up dw, 2 ; bring 'signal counter', 'last state', alarmed flag' and 'armed flag' to top\n swp b ; bring 'last state' to top\n ret\n\ntimeout4\n pop w ; dispose 'timer end time'\n shr 1 ; shift 'signal counter' right\n dup b ; save 'signal counter'\n psh 2 ; push 00000010 mask to stack\n ; compare 00000010 with 'signal counter'\n ; if equal - set timer for 128 ticks\n ; else - check with 00000001 mask\n cmp b\n skz\n bra check_00000101 ; 1\nsignal_gap_for_128_ticks\n pw 128 ; 0\n bra start_n_timer\ncheck_00000101\n dup b ; save 'signal counter'\n psh 5 ; push 00000101 to stack\n ; check 'signal counter' matching 00000101 \n ; if match - set timer for 32 ticks\n ; else - dispose 'last state' and 'signal counter' and set off\n and b\n pop b\n snz\n bra stop_signaling_dispose ; 1\nsignal_for_32_ticks\n pw 32 ; 0\n bra start_n_timer\nstop_signaling_dispose\n pop w ; dispose 'last state' and 'signal counter'\n pw 0 ; set off relay state and 'signal counter' = 0\n ret\n \nstart_n_timer\n ; get current ticks\n psh TICKS\n inp b, w\n add w ; calculate 'timer end time'\n up dw, 2 ; bring 'signal counter', 'last state', 'armed flag' and 'alarmed flag' to top\n swp b ; bring 'last state' to top\n ; flip the 'last value' (1 to 0, 0 to 1)\n psh 1\n xor b\n ret\n\ncheck_for_panic\n ; get panic status considering include panic flag\n pb PANIC\n inp b, b\n psh include_panic\n and b\n pop b ; read panic status\n ; if panic - check for timer\n ; else - check alarming\n snz\n bra check_alarming\n psh 0 ; set 'fire flag'\n bra check_for_timer\n\ncheck_alarming\n ; get alarming sections mask\n psh ALARMING_SECTIONS\n inp b, b\n pb sections\n and b ; calculate monitored alarming sections mask\n ; if has alarms - check if it's fire\n ; else - no alarm, set off\n skz\n bra check_is_fire\n ; already have 0 on top use it as 'alarmed flag'\n pb swap_and_off\n jmp b\n\ncheck_is_fire\n ; get fire sections mask\n psh FIRE_SECTIONS\n inp b, b\n and b ; calculate monitored fire alarms\n pop b ; read monitored fire alarms\n psh 0 ; set base 'fire alarm'\n ; if has fire alarm - set 'fire alarm' flag = 1\n ; else - leave 'fire alarm' = 0\n skz\n nib 1 ; set 'fire alarm' flag = 1\n \ncheck_for_timer ; 0 not fire\n swp w ; bring 'timer end time' to top\n ; if no timer started - start timer\n ; else - check timer\n skz\n bra check_timer\n pop w ; dispose timer place\n bra start_timer\n\nset_off\n swp w ; bring 'timer end time' to top\n pop w ; dispose 'timer end time'\n psh 0 ; set 'signal counter' = 0\n psh 0 ; set off relay action\n ret\n\nstart_timer\n psh TIMESTAMP\n inp b, w ; get current timestamp\n pw timer * 60\n add w ; calculate 'timer end time'\n bra set_on\n \ncheck_timer\n dup w ; save 'timer end time'\n psh TIMESTAMP\n inp b, w ; get 'current timestamp'\n ; compare 'current timestamp' and 'timer end time'\n ; if 'current timestamp' is greater - time is out\n ; else - continue, set on\n cmp w\n skp\n bra timeout\n \nset_on\n swp w ; bring 'fire alarm' and 'armed flag' to top\n ; read 'fire alarm' flag\n pop b\n ; if 'common alarm' flag is 0 - process fire siren\n ; else - regular siren\n skz\n bra fire ; 1\njust_on\n psh 0 ; set 'alarmed flag'\n bra swap_and_on\n \ntimeout\n pop w ; dispose 'timer end time'\n pop b ; dispose 'fire alarm' flag\n psh 1 ; set 'alarmed flag'\n swp b ; bring 'armed' to top\n pb set_off\n jmp b\n\nfire\n pw 7423 ; push base of zone uid address\n ; get zone id where script is attached\n pb 17\n inp b, w\n ; calculate address of zone uid\n add w\n inp w, b ; get zone uid\n psh 5 ; uid of some specific zone type (can't recall which)\n ; compare 'zone uid' and 'specific uid'\n ; if equal - it can blink, so blink\n ; else - it cannot\n cmp b\n skz\n bra just_on\n\nblink\n ; get ticks\n psh TICKS\n inp b, b\n pb mask ; push blinking mask to stack\n and b ; calculate matching ticks with a mask\n pop b ; read result\n psh 0 ; set 'alarmed flag'\n ; if match with mask - set off\n ; else - set on relay action\n skz\n bra swap_and_off\nswap_and_on\n swp b ; bring 'armed' to top\n psh 0 ; set 'signal counter' = 0\n psh 1 ; set on relay action\n ret\nswap_and_off\n swp b ; bring 'armed' to top\n psh 0 ; set 'signal counter' = 0\n psh 0 ; set off relay action\n ret